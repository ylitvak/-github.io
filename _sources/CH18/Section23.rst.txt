Section 23: Design by Analogy Mapping Transfer
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

.. youtube:: PWVsWf-HQ3w
        :height: 315
        :width: 560
        :align: left

.. image:: ../../_static/Ch18/Slide23-01.png
        :height: 200px
        :width: 350px
        :alt: Class Goals

.. image:: ../../_static/Ch18/Slide23-02.png
        :height: 200px
        :width: 350px
        :alt: Class Goals

.. image:: ../../_static/Ch18/Slide23-03.png
        :height: 200px
        :width: 350px
        :alt: Class Goals

.. image:: ../../_static/Ch18/Slide23-04.png
        :height: 200px
        :width: 350px
        :alt: Class Goals


Recall that we started with a problem of de- signing a robot, that can walk on water. Let us suppose that, that particular target problem resolves in the retrieval of a source case, of a robot design that we already encountered. One that can walk on ground. Now the question becomes, how can we adapt this particular design of the robot that can walk on the ground, into a robot design that can walk on water? Let us now sup- pose, if we reuse this particular problem of designing a robot to walk on water. As a probe into the case memory. And now the case returns to us, the design of the basilisk lizard. That might happen, because the design of the basilisk lizard, is indexed by it’s functional model, walk on water. So there is a pragmatic similarity be- tween the two. We now have the design of a robot who can walk on ground, and we have the design of a biological organism, the Basilisk Lizard, that can walk on water. For the Basilisk lizard, we also have a complete model, a complete explanation of how its structure achieves its function. Now that we have a partial de- sign for the robot, this is a design of the robot that can walk on ground. And we have a design of an organism that can walk on water. We can try to do an alignment between these two. This alignment will be based on the similarity between relationships. Clearly, the objects here, and objects there are very different. Once we have aligned these structural models, or the robot that can walk on ground, and the basilisk lizard that can walk on water. Then, we can start doing transfer. We can transfer specific features, of the structure of the basilisk lizard. For example, the shape of its feet, to this model, of the robot that can walk on ground. In order to convert it into a robot, it can walk on water. Having constructed a structural model, for this robot that can walk on water then we can try to transport the behavioral model, and then the functional model. And then this way we have a complete model of a robot that can walk on water. Along with an explanation of how it will achieve it’s function. This is sometimes called compositional analogy. We’ll first do mapping at the level of structure, and that mapping at a level of structure helps us transfer some information. That in turn allows us to transfer information at the behavioral level. Once we have transferred information at the behavioral level, we can climb up this abstraction hierarchy, and transfer information at a functional level. We can now revisit our computational process, and our logical reasoning. Initially we had presented this particular process like, a linear chain, Retrieval, Mapping, Transfer, Evaluation and Storage. In general, however, there can be many loops here. We may do some initial mapping, for example, that may result in some transfer of information. But that transfer then, may lead to additional mapping, and then to additional transfer and so on. Here is another brief example, from biological inspired design, in this case we want to design a robot that can swim under water in a very slowly manner. This particular function of swimming underwater in a stealthy manner, re- minds a design team of a copepod. A copepod is a biological organism, that has a large number of appendages. It moves underwater, in such a way that in generates minimum wake, especially when it moves very slowly. On the other hand, when it moves rapidly, then the wake becomes large, when the wake is small then its motion is very steady, when the wake is large, its motion is no longer steady. An analogically transfer of knowledge about this particular copepod, gives a design for the microbot for slow velocity. This analogy, decomposes our original design problem. We had the original design problem, as moving underwater in a stealthy manner. Now that we have a design of an organism, for moving underwater at low velocities, we are still left with the sub goal of moving underwater at high velocities. The goal of designing a microbot, that can move underwater in a stealthy manner, at fast velocities, may remind the design team of the squid. The squid uses a special mechanism, like the jet propulsion mechanism to move underwater in a stealthy manner at pretty high velocities. Now we have created a designed for microbot. Where part of the design comes from the design of the copepod, and the other part comes from the design of the squid. Instead of borrowing the design from one source case, we are borrow- ing parts of the design of multiple source cases. This is a compound analogy. Notice that there’s a problem evolution going on, which started with one problem. We arrived at a partial solution to that. Which then leads us to a problem evolution. And the problem transformation. We then have a new understanding of the problem. So, this example we saw, how we first did analogical retrieval of the coco powder organism. Then Mapping, then Transfer. That then lead to addition retrieval, in this case with a squid. Once again this process is not linear. Just like we can iterate between Mapping and Transfer, similarly we can iterate between Transfer and Retrieval.