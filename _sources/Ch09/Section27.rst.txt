Section 27: Advanced Case-Based Reasoning
:::::::::::::::::::::::::::::::::::::::::

.. youtube:: kpElMpjtHmQ
        :height: 315
        :width: 560
        :align: left

So far we have talked about the very basic process of case based reasoning and we have portrayed as if this process was linear. But of course the case based reasoning process may not necessarily be linear. As an example, if the evaluation fails, then we might want to adapt that particular case in a different way. As an example of the evaluation of the candidate solution, that adaptation had produced fails. Then, instead of abandoning that particular case, you might want to try to adapt it again. Alternatively, if we try to adapt the same case several times, but we just cannot adapt it, we might want to abandon that case and try to find a different case from the case memory. There is another possibility. Suppose that we retrieve a case from memory. And we try to adapt it but we are unable to adapt it to meet the requirements of the new problem. In that case, you might want to abandon the case and try to do a new one. There is yet another possibility. Let us suppose that we retrieve a case from memory and it exactly matches the new problem. In that case, no adaptation needs to be done and we can jump down to evaluation. In fact this is what happened when we're discussing the KNN method. In this way we can see that there are many ways in which this process need not necessarily be linear. So Ashok, earlier you said that if the evaluation shows that the new solution is good, then we should store it. If the evaluation shows that the new solution is not good, we should try adapting again or we should try retrieving again. But what about evaluation showing that new solution is not good? Should we ever store those? Indeed, sometimes studying failed cases is also very useful. Failed cases can help us anticipate problems. So imagine if you're given a new problem, and you retrieve from your case memory a failed case. That failed case can be very useful because it can help you anticipate the kinds of problems that will occur in solving the new problem. So that reminds me of another example from our file input problem. One thing I've encountered a lot when I'm doing a file input is that if you read too far in the file, then the program will crash and it'll give you an error. It will always give you the same error, and it's a very common problem because different languages do file input slightly differently. So in my mind, I must have cases of the different ways that it's failed in the past, so I can anticipate those and do it correctly in the future. Failures are great opportunities for learning. When failures occur, we can try to repair the failure by going back from the evaluation step to the adaptation step. Or we can try to recover from the failure by going from the evaluation step all the way to the retrieval step. In addition, we can store these failures in the case memory. When we store them in the case memory, then these failures can help us anticipate failures that might occur with new problems. There's a flip side to this. Just like it is useful to store failed cases, it is not useful to store every successful case. If we stored every successful case, then very soon the case memory will become very, very large, and the retrieval step will become less efficient. This is sometimes called the utility problem. We want to store only those successful cases that in fact help us cover a larger span of problems. This means that, even when a case succeeds, we want to store it only if there is something interesting or noteworthy about that case.
