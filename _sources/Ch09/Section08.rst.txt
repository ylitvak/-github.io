Section 08: Case Adaptation by Recursive Reasoning
::::::::::::::::::::::::::::::::::::::::::::::::::

.. youtube:: pMZTHuKpOxQ
        :height: 315
        :width: 560
        :align: left

A second method to adapt cases is to use case based reasoning recursively. So last time we considered problem which I had to go from my office to a restaurant, and I found a way of doing that. Now suppose that I have to go from my home to the same restaurant. So I don't yet know how to go from my home to the restaurant, but I know how to go from my home to my office. And this last time, I figured out a way of going from office to the restaurant. So there we have it. Now I have a case retrieved for going from home to office, another case retrieved for going from office to the restaurant, and I have a solution. We're going from home all the way to the restaurant. This is an example of case based reasoning. Your first time you retrieve a case for solving a problem, the case provides a partial solution. So I take the remaining part which was not solved, make it a new problem, and send it back into the case memory. Now the case memory finds me a new case. And I take this new case and I compose it with the previous case to get a full solution. So to return again to our programming example, when I'm designing a program, my file input is usually part of a broader problem of persisting data between instances of the program. And thus, the real problem I'm solving is solving this problem of how to save data when the program isn't running. I can then solve that problem recursively by breaking it down into the first problem of file input and the second problem of file output. I might draw a case for solving file input from one program I've done in the past and a case for solving file output from another program in the past. So I've solved it recursively by breaking it down into sub problems. David, to build on what you just said, the same kind of thing occurs in design in general. Often when we do design, we get partial solutions for multiple cases. For example, consider the problem of designing a microbot that can swim underwater in a very stealthy manner. This might remind me of a case of a copepod which has large number of appendages and swims in the water at very slow velocity making minimum wake in the water. That's good, I've now solved part of the problem, the part which had to do with moving stealthily underwater under slow speeds. But that now sets up a new goal, how do I achieve stealthy motion underwater at high speeds? And I may come up with a solution from a different case. So a squid, for example, also swims stealthily underwater, but it does so by creating a wake that matches the natural wake of water around it. So here I first used the goal of designing a microbot that can swim underwater stealthily to retrieve a case of the copepod. That provide me with a partial solution. So I set up a new sub-goal to complete the solution. The new sub-goal found a new case, that of the squid, which gave me the rest of the solution. And if I compose the two partial solutions, I get the complete solution. So what Ashok just described is something that we call compound analogy, which is a specific type of adaptation by recursive reasoning. If you're interested in that example, we've provided a paper on it in the course materials for this lesson. So you can read more about the process of adapting those cases to solve that very unique and complex design problem.
