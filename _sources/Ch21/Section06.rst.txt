Section 06: The Configuration Process
:::::::::::::::::::::::::::::::::::::

.. youtube:: G8M39axPT3Q
        :height: 315
        :width: 560
        :align: left

Here's an abstract specification of a knowledge-based AI method for doing configuration design. The process starts with some specifications. These might be the specifications of all the constraints on this configuration problem, for example the constraints on David's basement. The output is an arrangement model, a model of the arrangement of all the components with the components already known, for example, the arrangement of David's basement. In this matter, for some configuration design, we begin with some very abstract, and perhaps partial solutions. This abstract and partial solution may be represented in the form of a design plan. So, an abstract and journal plan for basements of houses. Each plan specifies a subset of all the variables. We assign values to the variables in that plan. The plan is now complete. A completed plan can now be refined and expanded. At the next lower level, the plan specifies more variables. We assign values to those variables. Now that plan at the next level is complete, and we continue this iterative process until we have a complete arrangement model. As an example, if somebody was building a residential home, like David is doing right now, then the abstract plan may deal with the number of stories that the house will have. Once we assign to the variable number of stories, then we get a more expanded and refined plan where we have a plan for each of the stories including the basement. For example, for the main floor, there might be a plan which specifies something about a kitchen area, something about a living area, something about a bedroom area. As we assign values to the variables that define the living area, and the kitchen area, and the bedroom area, this plan gets completed. And now we might refine it further, a more detailed plan for the living area, for example. This abstraction hierarchy is a diagrammatic representation of this plan's arrangement from those abstraction. I begin with the most abstract plan, then I refine them and expand them as I go down. As I said earlier in configuration design, all the components are already known. Nevertheless, in some cases it might be able to also select the components. So for example, I might not only be able to reconfigure the TV, I might also be able to pick a specific kind of TV. So this might be a TV in general and a more specific kind of TV and more specific kind of TV and so on. Note that the arrows coming here are two way arrows. This is intentional. In particular, let us look at the two way arrows between the arrangement model and the process of configuration and the specifications and the configuration process. Once this process has yielded an arrangement model, then we can assess the arrangement model and if needed go back to the process. As an example, the configuration process says that the TV is 12 feet away from the couch. And we assess it, and we decide the couch is too close to the TV. Then we can go back to the process and say, make the couch more than 12 feet away from the TV. That then becomes an additional specification here. And this is the meaning of the two way arrow. It is not just that we start with specifications and the configuration process works to satisfy them, but also, as the configuration process works and results in solutions, we can evaluate those solutions. And the specifications may change. This is a very common property of all design. One of the major differences between design and problem solving is that in problem solving, the problem typically remains fixed when we come up with a solution. In contrast in design, the problem evolves as the solution evolves. The problem and the solution co-evolve. So we start with a problem of satisfying certain constraints, but as the solution evolves, the evolution of the solution results in the evolution of a problem. As an example, let us suppose that the configuration problem is to configure the parts of a computer processor so that the processor can work at a particular speed. To do so, you come up with an arrangement model, but when you evaluate it, you find that the processor overheats. In that case, you may change the specification and say that the specification is not only that the processor should be fast enough, but also that it should not overheat. This is an example of problem evolution and solution evolution. Now that the problem has evolved, you may come up with a new solution for the processor design. This now is an example of problem evolution and solution evolution. So for an example that might hit a little bit closer to home for many of you, as you've been designing your agents that can solve the Raven's test, you've done a process somewhat like this. You started with some specifications, general specifications, that your agent must be able to solve as many problems on the Raven's test as possible. You then start with an abstract solution of just a general problem solving process that you may have then refined to be more specific about the particular transformations to look for or the particular problem solving methods to use. That got you to your final result. But when you ran your file result, you may have found something like it would work but it would take a very, very long time to run, weeks or months. So that then causes you to revise your specifications. You not only need an agent that can solve as many problems as possible, but you also need one that can solve it in minutes or seconds instead of weeks or months.

.. reveal:: revealconfigurationreading2
    :showtitle: Show Reading
    :hidetitle: Hide Reading

    .. raw:: html

        <center>
        <iframe height=600px width=800px src=../_static/readings/Configuration/Stefik+Configuration+Part+2_Pgs+656-666_.pdf>
        </iframe>
        </center>
or download :download:`here <../_static/readings/Configuration/Stefik+Configuration+Part+2_Pgs+656-666_.pdf>`
